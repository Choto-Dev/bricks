{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "editor",
  "type": "registry:component",
  "title": "Editor",
  "description": "A tiptap editor.",
  "dependencies": [
    "@tiptap/core@3.13.0",
    "@tiptap/react@3.13.0",
    "@tiptap/starter-kit@3.13.0"
  ],
  "files": [
    {
      "path": "src/registry/bricks/tiptap-editor/components/editor.tsx",
      "content": "\"use client\";\r\n\r\nimport type { Editor as EditorType, JSONContent } from \"@tiptap/core\";\r\nimport { EditorContent, useEditor, useEditorState } from \"@tiptap/react\";\r\nimport StarterKit from \"@tiptap/starter-kit\";\r\nimport React from \"react\";\r\nimport \"@/registry/bricks/tiptap-editor/styles/editor.css\";\r\n\r\ntype TEditorContent = JSONContent | string;\r\ntype EditorContextProps = {\r\n  editor: EditorType | null;\r\n  editorState: {\r\n    isEditorFocus: boolean;\r\n  } | null;\r\n  initialContent: TEditorContent;\r\n  setInitialContent: React.Dispatch<React.SetStateAction<string | JSONContent>>;\r\n  currentContent: TEditorContent;\r\n};\r\nconst EditorContext = React.createContext<EditorContextProps>({\r\n  editor: null,\r\n  editorState: null,\r\n  initialContent: \"\",\r\n  setInitialContent: (content: TEditorContent) => content,\r\n  currentContent: \"\",\r\n});\r\nfunction useEditorContext() {\r\n  const ctx = React.useContext(EditorContext);\r\n  return ctx;\r\n}\r\n\r\nfunction EditorRoot({ children }: { children: React.ReactNode }) {\r\n  const [initialContent, setInitialContent] =\r\n    React.useState<TEditorContent>(\"\");\r\n  const [currentContent, setCurrentContent] =\r\n    React.useState<TEditorContent>(\"\");\r\n\r\n  const editor = useEditor(\r\n    {\r\n      extensions: [StarterKit],\r\n      immediatelyRender: false,\r\n      content: initialContent,\r\n      onUpdate: async ({ editor }) => {\r\n        setCurrentContent(editor.getJSON());\r\n      },\r\n    },\r\n    [initialContent],\r\n  );\r\n  const editorState = useEditorState({\r\n    editor,\r\n    selector: (ctx) => {\r\n      return {\r\n        isEditorFocus: ctx.editor?.isFocused ?? false,\r\n        isBold: ctx.editor?.isActive(\"bold\") ?? false,\r\n        canBold: ctx.editor?.can().chain().toggleBold().run() ?? false,\r\n        isItalic: ctx.editor?.isActive(\"italic\") ?? false,\r\n        canItalic: ctx.editor?.can().chain().toggleItalic().run() ?? false,\r\n        isStrike: ctx.editor?.isActive(\"strike\") ?? false,\r\n        canStrike: ctx.editor?.can().chain().toggleStrike().run() ?? false,\r\n        isCode: ctx.editor?.isActive(\"code\") ?? false,\r\n        canCode: ctx.editor?.can().chain().toggleCode().run() ?? false,\r\n        canClearMarks: ctx.editor?.can().chain().unsetAllMarks().run() ?? false,\r\n        isParagraph: ctx.editor?.isActive(\"paragraph\") ?? false,\r\n        isHeading1: ctx.editor?.isActive(\"heading\", { level: 1 }) ?? false,\r\n        isHeading2: ctx.editor?.isActive(\"heading\", { level: 2 }) ?? false,\r\n        isHeading3: ctx.editor?.isActive(\"heading\", { level: 3 }) ?? false,\r\n        isHeading4: ctx.editor?.isActive(\"heading\", { level: 4 }) ?? false,\r\n        isHeading5: ctx.editor?.isActive(\"heading\", { level: 5 }) ?? false,\r\n        isHeading6: ctx.editor?.isActive(\"heading\", { level: 6 }) ?? false,\r\n        isBulletList: ctx.editor?.isActive(\"bulletList\") ?? false,\r\n        isOrderedList: ctx.editor?.isActive(\"orderedList\") ?? false,\r\n        isCodeBlock: ctx.editor?.isActive(\"codeBlock\") ?? false,\r\n        isBlockquote: ctx.editor?.isActive(\"blockquote\") ?? false,\r\n        canUndo: ctx.editor?.can().chain().undo().run() ?? false,\r\n        canRedo: ctx.editor?.can().chain().redo().run() ?? false,\r\n      };\r\n    },\r\n  });\r\n\r\n  if (!editor) {\r\n    return null;\r\n  }\r\n\r\n  const value = {\r\n    editor,\r\n    editorState,\r\n    initialContent,\r\n    setInitialContent,\r\n    currentContent,\r\n  };\r\n\r\n  return <EditorContext value={value}>{children}</EditorContext>;\r\n}\r\n\r\nfunction EditorEditor({\r\n  content,\r\n  onContentUpdate,\r\n}: {\r\n  content?: TEditorContent;\r\n  onContentUpdate?: (content: TEditorContent) => void;\r\n}) {\r\n  const ctx = useEditorContext();\r\n\r\n  if (!ctx) {\r\n    throw new Error(\"Editor.Editor should be in Editor.Root\");\r\n  }\r\n\r\n  React.useEffect(() => {\r\n    if (content) {\r\n      ctx.setInitialContent(content);\r\n    }\r\n    if (onContentUpdate && ctx.editor) {\r\n      onContentUpdate(ctx.editor?.getJSON());\r\n    }\r\n  }, [ctx, content, onContentUpdate]);\r\n\r\n  if (ctx.editor === null) {\r\n    return <div className=\"text-destructive\">Editor failed to initiate</div>;\r\n  }\r\n\r\n  return <EditorContent editor={ctx.editor} />;\r\n}\r\n\r\nfunction EditorReadOnly() {\r\n  const ctx = useEditorContext();\r\n\r\n  if (!ctx) {\r\n    throw new Error(\"Editor.Editor should be in Editor.Root\");\r\n  }\r\n\r\n  const editor = useEditor(\r\n    {\r\n      extensions: [StarterKit],\r\n      immediatelyRender: false,\r\n      content:\r\n        typeof ctx.currentContent === \"string\"\r\n          ? ctx.initialContent\r\n          : ctx.currentContent,\r\n      editable: false,\r\n    },\r\n    [ctx],\r\n  );\r\n\r\n  return <EditorContent editor={editor} />;\r\n}\r\n\r\nconst Root = EditorRoot;\r\nconst Editor = EditorEditor;\r\nconst ReadOnly = EditorReadOnly;\r\n\r\nexport { Root, Editor, ReadOnly };\r\n",
      "type": "registry:component",
      "target": "components/bricks/tiptap-editor/editor.tsx"
    },
    {
      "path": "src/registry/bricks/tiptap-editor/styles/editor.css",
      "content": ".ProseMirror:focus-visible {\r\n  outline: none;\r\n  border: none;\r\n  box-shadow: none;\r\n}\r\n",
      "type": "registry:style",
      "target": "components/bricks/tiptap-editor/editor.css"
    }
  ]
}